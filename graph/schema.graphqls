#### GRAPHQL SDL ####
scalar Time

type User {
  user_id: Int! ## SQL generated PK
  username: String!
  email: String!
  ## password - not shared via graphql
  posts: [Post]
  created_at: Time!
}

input UserSearch {
  username: String ## nullable for when searching all users
  limit: Int!
  offset: Int!
}

type PaginatedUsers {
  users: [User]
  more: Boolean!
}

input UserInput {
  username: String!
  email: String!
  password: String!
}

# Votes is a calculated object returning the up and down votes for either
# a post or a comment
type Votes {
  upvote: Int!
  downvote: Int!
}

enum VoteValue {
  upvote
  downvote
  neutral
}

# tracked vote record for particular posts. Maps to SQL Many to Many relationship.
type PostVote {
  post_id: Int!
  vote_value: VoteValue!
  user_id: Int!
}

type Post {
  post_id: Int!
  user_id: Int!
  user: User # field resolver
  title: String!
  subtitle: String! ## optional
  post_text: String! ## will store a JSON-serialized version of the HTML markup
  created_at: Time!
  votes: Votes! ## field resolver
  deleted: Boolean! ## deleted posts will still be stored in the database
  ## to allow for undoing a delete and restoring posts / comments / votes
}

input PostInput {
  title: String!
  subtitle: String
  text: String!
}

input PostSearch {
  title: String ## nullable for when not specifying a title
  limit: Int!
  offset: Int!
}

type PaginatedPosts {
  posts: [Post]
  more: Boolean!
}

# tracked vote record for particular comments. Maps to SQL Many to Many relationship.
type CommentVote {
  comment_id: Int!
  vote_value: VoteValue!
  user_id: Int!
}

type Comment {
  comment_id: Int!
  response_to_comment_id: Int # used when one comment is in response to another comment, nesting it
  post_id: Int!
  user_id: Int!
  user: User! ## field resolver
  comment_text: String!
  created_at: Time!
  votes: Votes! ## field resolver
  deleted: Boolean! ## deleted comments will still be stored in the database
  ## to allow for undoing a delete and restoring comments / votes
}

input CommentSearch {
  post_id: Int!
  comment_id: Int ## nullable comment_id will be used for retrieving subcomments
  offset: Int!
  limit: Int!
}

type PaginatedComments {
  comments: [Comment]
  more: Boolean!
}

type Query {
  getPost(post_id: Int!): Post ## nullable for when no post found
  getUser(user_id: Int!): User ## nullable for when no user found
  getManyPosts(postSearch: PostSearch!): PaginatedPosts!
  getManyUsers(userSearch: UserSearch!): PaginatedUsers!
  getManyComments(commentSearch: CommentSearch!): PaginatedComments! # field resolver
  # authentication:
  me: User # authenticate signed in user
  isAuthor(user_id: Int!): Boolean! # authenticate author
}

type Mutation {
  addPost(postInput: PostInput!): Post!
  editPost(post_id: Int!, postInput: PostInput!): Post!
  deletePost(post_id: Int!): Boolean!
  restorePost(post_id: Int!): Boolean!
  addComment(
    post_id: Int!
    response_to_comment_id: Int
    comment_text: String!
  ): Comment!
  editComment(comment_id: Int!, new_comment_text: String!): Comment!
  deleteComment(comment_id: Int!): Boolean!
  restoreComment(comment_id: Int!): Boolean!
  voteOnPost(post_id: Int!, vote_value: VoteValue!): PostVote!
  voteOnComment(comment_id: Int!, vote_value: VoteValue!): CommentVote!
  # authentication:
  registerNewUser(userInput: UserInput!): User!
  login(username: String!, password: String!): User!
  logout: Boolean!
  forgotPassword(username: String!): Boolean!
  resetPassword(username: String!, new_password: String!): User!
}
